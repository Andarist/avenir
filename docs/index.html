<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Home - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Future.html">Future</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Future.html#subscribe">subscribe</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Future.html#fork">fork</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Future.html#cancel">cancel</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Future.html#then">then</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Future.html#orElse">orElse</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Future.html#.of">of</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Future.html#.resolve">resolve</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Future.html#.reject">reject</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Future.html#.cancel">cancel</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Future.html#.empty">empty</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Future.html#.all">all</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Future.html#.race">race</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Task.html">Task</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Task.html#run">run</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Task.html#orElse">orElse</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Task.html#then">then</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Task.html#log">log</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Task.html#.of">of</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Task.html#.resolve">resolve</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Task.html#.reject">reject</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Task.html#.cancel">cancel</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Task.html#.from">from</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Task.html#.join">join</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Task.html#.empty">empty</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Task.html#.race2">race2</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Task.html#.race">race</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Task.html#.zipw">zipw</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Task.html#.all">all</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Task.html#.traverse">traverse</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Task.html#.detect">detect</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Task.html#.apply">apply</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Task.html#.lift">lift</a></span></li><li class="nav-heading"><a href="global.html">Globals</a></li>
</nav>

<div id="main">
    

    



    









    


    <section class="readme">
        <article><h1>avenir</h1><p>Lightweight async library based on lazy Futures. Inspired by
<a href="https://github.com/folktale/data.task">folktale's Data.Task</a></p>
<p>The library provides <code>Tasks</code> for writing asynchronous code with JavaScript in
Node and the Browser.</p>
<p>Unlike Promises, Tasks are <em>lazy</em> and <em>cancellable</em>.</p>
<blockquote>
<p>the following section is on how Tasks tries to solve some of the issues with former Task based TC39 proposal. 
Points listed in a random order here. Needs rewrite.</p>
</blockquote>
<p>Basically avenir Task build on <a href="https://github.com/tc39/proposal-cancelable-promises/issues/2">proposal-cancelable-promises/issues/2</a>.
But unlike the proposal which evolves in a highly constrained environment (backward compatibility, consensus ...). The
library doesnt aim to be a compatible Promise implementation. Instead we start from scratch taking different design decisions
and tradeoffs (mainly simplicity and ergonomics).</p>
<p>In the following I use the term Promise to makes explanations simpler. But the library has its own Promise implementation called Future.</p>
<ul>
<li><p>Task is not a sublcass of Promise but wraps a lazy Promise chain for which it's the only owner. Thus it can describe an atomic operation and gives clearer meaning to cancellation. IMHO ref counting for handling cases like <a href="https://github.com/tc39/proposal-cancelable-promises/blob/19b48e28d768d84cff8c2b69f61f710376eb9394/Subclass%20Brainstorming.md#canceling-derived-tasks">this one</a> is not the best way (because a Promise is multicast and we can chain further operations <em>after</em> the refcount reaches 0).</p>
</li>
<li><p>Task executes/propagates synchronously hence no race conditions like <a href="https://github.com/tc39/proposal-cancelable-promises/issues/8">tc39/proposal-cancelable-promises/issues/8</a>. (reentrance issues due to synchronous execution/propagation are handled by spec. guards. It's way simpler to handle reentrance than correctly implement cancellation with async shcduling)</p>
</li>
<li><p>Task doesn't flatten nested Promises so clearer meaning of what to expect from  <a href="https://github.com/tc39/proposal-cancelable-promises/issues/8">tc39/proposal-cancelable-promises/issues/8</a> or also <a href="https://github.com/tc39/proposal-cancelable-promises/blob/19b48e28d768d84cff8c2b69f61f710376eb9394/Subclass%20Brainstorming.md#cancelation-vs-resolution">from this example</a>. A Promise is completed simply when it's not in PENDING state. Thus examples like this</p>
</li>
</ul>
<pre class="prettyprint source lang-js"><code>const task = new Task(resolve => {
  resolve(new Promise(() => {}));

  return cancelAction;
});
task.cancel();</code></pre><p>are not legitimate because we can not call the <code>resolve</code> capability with another Promise (In fact we can but the inner
Promise is passed to chained callbacks as a normal value).</p>
<p>avenir Tasks differ also in a few point from folktale Data.Task. See <a href="comparison.md">comparisaon</a>.</p>
<h2>Rationale</h2><p>Consider the following example using Promises</p>
<pre class="prettyprint source lang-js"><code>var promiseA = someAsynFn()
var promiseB = promiseA.then(...)</code></pre><p>Let's suppose that Promises were given builtin cancellation. And that we invoke
<code>promiseB.cancel()</code>. The question is how do we interpret the effects of this
cancellation ?</p>
<ol>
<li>Should we only cancel <code>promiseB</code> and not touch <code>promiseA</code> ?</li>
<li>Or should we also cancel <code>promiseA</code> ?</li>
</ol>
<p>In case of (1) then what if the code represented an atomic operation ? In this
case a cancellation means cancelling the whole operation and this implies
cancelling also <code>promiseA</code> if it's still pending.</p>
<p>Note that even of we write it inline like this</p>
<pre class="prettyprint source lang-js"><code>var promiseB = someAsynFn().then(...)</code></pre><p>There is no way we can infer the atomicity of the operation because Promises are
immutables and each invocation of <code>then</code> returns a new Promise. The new Promise
itself is not aware of how it was derived.</p>
<p>Now if we choose (2) and cancel the whole chain, then imagine there is another
operation that was attached to <code>promiseA</code> (or that will be attached in some point
of the future[no pun intended] in our code).</p>
<pre class="prettyprint source lang-js"><code>var promiseA = someAsynFn()
var promiseB = promiseA.then(...)
var promiseC = promiseA.then(...)</code></pre><p>Now if <code>promiseB.cancel()</code> triggers cancellation on <code>promiseA</code> then this cancellation
will propagate downward and cancel also <code>promiseC</code> (because it can not be derived
from a cancelled Promise) but we were only aiming at cancelling <code>promiseB</code>
not <code>promiseC</code>.</p>
<p>Here we have 2 separate chains <code>promiseA -&gt; promiseB</code> and <code>promiseA -&gt; promiseC</code>.
Another perspective is to view the operation as a <em>tree</em> with <code>promiseA</code> as root and
with 2 branches whose leafs are <code>promiseB</code> and <code>promiseC</code>. So cancelling one branch
should not affect the other branch (however cancelling the root or cancelling
the <em>whole</em> tree should propagate to the branches as well).</p>
<p>A possible solution is to maintain some ref. couning in <code>promisA</code>. Each time we chain
a <code>then</code> operation we increase the counter if <code>promiseA</code> and once the derived 
promise is completed (whatever the outcome) we decrese the counter. If the counter
reaches <code>0</code> then we cancel <code>promiseA</code> since all operations that depend on it
have completed.</p>
<p>But ref. couting can have subtle issues. For example what if <em>after</em> <code>promiseB</code> and
and <code>promiseC</code> aer cancelled - cancelling <code>promiseA</code> in the way - we reattach another
<code>then</code> operation in some other part of the code ? And I dont mention here issues 
related to race conditions due to async scheduling of chained operations which makes
maintaining the ref. counter error prone. Issues like <a href="https://github.com/tc39/proposal-cancelable-promises/issues/8">this one</a>
is a simple illustration. And I'd expect more subtle issues to manifest in real world
applications (I've myself experienced many of those issues when implementing <a href="https://github.com/redux-saga/redux-saga">redux-saga</a>
and I couldn't get rid of them until I dropped async scheduling in sequenced 
operations and made everything synchronous).</p>
<p>So it's clear how we should propagate cancellation up depends on the
situation. But the problem is precisely how do we infer this situation. A Promise, 
once created, lacks the <em>whole context</em> in which it is itself composed with other 
Promises to build a control flow. While we can maintain a reference to the parent
promise from which the current promise was derived. We can not know how this
parent promise is used elsewhere and all the other operations that has been or
<strong>will be</strong> derived from it.
 So we can not simply implement a <code>cancel</code> method in the Promise prototype because 
we do not have enough information to interpret the meaning of the cancellation.</p>
<p>Another solution is to extract out the cancellation capability into a first
class value. For example we can create some token and then pass it down
to all async operations that construct Promises. The creator of the token can
request the cancellation at any moment. The async operations that have
received the token can then be notified of the cancellation. This is the
solution that was planned to be implemented into the TC39 standard (but was
dropped because of lack of consensus).</p>
<p>We can view the token based solution as an indirect way to describe chained
steps as a whole unit. A created cancel token denote itself the whole operation
and all async functions that receive the token are part of the unit.</p>
<p>Another solution, which IMHO is simpler, more composable and ergonomic is to
make this <em>whole operation</em> - the big picture - itself as a first class value
using <em>Tasks</em>.</p>
<h3>Tasks are lazy Promises</h3><p>A Task can be thought of as a <em>lazy Promise</em>. For example, the following Promise</p>
<pre class="prettyprint source lang-js"><code>const promiseA = new Promise((resolve, reject) = {
  invokeAsyncFunc((err, res) => {
    if(err) reject(err)
    else resolve(res)
  })
})</code></pre><p>Can be made lazy like this</p>
<pre class="prettyprint source lang-js"><code>const lazyPromiseA = () => new Promise((resolve, reject) = {
  invokeAsyncFunc((err, res) => {
    if(err) reject(err)
    else resolve(res)
  })
})</code></pre><p>The difference is that in the first case the operation is started right after the
Promise creation. While in the second we've only constructed a description of t
he operation.</p>
<p>Now suppose we want to <em>describe a new operation</em> that is the chaining of the above
and another one</p>
<pre class="prettyprint source lang-js"><code>const lazySequence = () => lazyPromiseA().then(...)</code></pre><p>So what's the difference ? one may ask.</p>
<p>Well in the case of normal/hot promises, we've seen that we can not interpret</p>
<pre class="prettyprint source lang-js"><code>var hotSequence = promiseA.then(...)</code></pre><p>as a whole operation that includes <code>promiseA</code> because this one can be used
elsewhere in another sequence.</p>
<p>However in the case of lazy Promises we do have this knowledge. Precisely because
the operation has not started yet. And simply because we will start it ourselves
as a whole operation.</p>
<p>So Tasks are just this and nothing more. The <a href="https://yelouafi.github.io/avenir/Task.html">Task</a>
abstraction provided by this library or by 
<a href="http://origamitower.github.io/folktale/en/folktale.data.task.html">folktale's Data.Task</a> 
just wraps this lazy execution and makes it more composable by providing functions to
describe the control flow (like <code>then</code>/<code>chain</code>, <code>all</code>, <code>race</code> ...)</p>
<p>In avenir, you can create a Task with a API similar to Promises using
<a href="https://yelouafi.github.io/avenir/Task.html#.from">Task.from</a>. Note the executor
argument takes also a <code>cancel</code> callback. This can be invoked by the executor to
trigger cancellation from the source.</p>
<pre class="prettyprint source lang-js"><code>const myTask = Task.from((resolve, reject, cancel) = {
  invokeAsyncFunc((err, res) => {
    if(err) reject(err)
    else resolve(res)
  })
})</code></pre><p>The executor of the Task is not started at the Task creation. It means no side
effect takes place at this moment yet. To effectively start a Task, you must
invoke its <code>run</code> method</p>
<pre class="prettyprint source lang-js"><code>// Execution starts from here
myTask.run(onSuccess, onError, onCancel)</code></pre><h3>Tasks are Cancellable</h3><p>After a Task has been started, it can be cancelled using the returned <a href="https://yelouafi.github.io/avenir/Future.html">Future</a></p>
<pre class="prettyprint source lang-js"><code>// Execution starts from here
const future = myTask.run(onSuccess, onError, onCancel)

// ... after some time
future.cancel('some reason')</code></pre><p>You can use <a href="https://yelouafi.github.io/avenir/Task.html#then">Task#then</a>
to chain another step</p>
<pre class="prettyprint source lang-js"><code>const myWholeTask = myTask.then(...)</code></pre><p>myWholeTask is a new Task that describes the whole sequence. So when starting it</p>
<pre class="prettyprint source lang-js"><code>// Task#fork is the same as Task#run but does not take callbcaks
const future = myWholeTask.fork()</code></pre><p>Cancelling the returned future will cancel the whole sequence. Due to their lazy
nature, Tasks give an unambiguous meaning to cancellation.</p>
<h3>Tasks are Joinable</h3><p>Sometimes a Task needs to <em>join</em> the result of an already started Task (ie a Future).
This can happen if, for example,  the 2 Tasks are started from 2 unrelated
contexts (like 2 events handlers in separate UIs).</p>
<p>For example suppose we have a login Task that is started when the user clicks on
a UI button</p>
<pre class="prettyprint source lang-js"><code>const loginTask = Task.from((resolve, reject, cancel) => {
  api.authorize((err, ok) => {
    // attach a cancellation from the source
    onCancelLoginClick(() => cancel('Login cancelled'))
    if(err) reject(err)
    else resolve(ok)
  })
})


let loginFuture

function loginClickHandler() {
  loginFuture = loginTask.run(onSuccess, onReject, onCancel)
}</code></pre><p>In another part of the UI, we want to start fetching something but only after the
login succeds. We can use <a href="https://yelouafi.github.io/avenir/Task.html#.join">Task.join</a>
to wait for loginFuture to finish</p>
<pre class="prettyprint source lang-js"><code>// Task.do allows using Generator syntax
const fetchDataTask = Task.do(function*() {
  yield Task.join(loginFuture)
  const data = yield myFetchTask
  return data
})</code></pre><p>Above, we used the Generator syntax to describe the operation. We wait for loginFuture
to resolve before continuing. If the login task was cancelled (either by invoking
<code>loginFuture.cancel()</code> or by the loginTask itself if the user clicks on a CancelLogin
button) then the fetchDataTask will be cancelled as well.</p>
<p>Observe that if we cancel fetchDataTask for some other reason while we're
still waiting for loginFuture</p>
<pre class="prettyprint source lang-js"><code>const future = fetchDataTask.fork()

// for some reason later
future.cancel('some reason')</code></pre><p>Then this will only affect fetchDataTask and not loginTask. Cancelling the result
of <code>Task.join(loginFuture)</code> (which is itself a Task) will only unsubscribe from
the result of loginFuture. The loginTask stays unaffected.</p>
<h1>Documentation</h1><p><a href="https://yelouafi.github.io/avenir/">API Docs</a></p></article>
    </section>






</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Sun May 14 2017 13:57:05 GMT+0000 (UTC) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>